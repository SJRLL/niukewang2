G社正在开发一个新的战棋类游戏，在这个游戏中，角色只能向2个方向移动：右、下。移动需要消耗行动力，
游戏地图上划分M*N个格子，当角色移动到某个格子上时，行动力就会加上格子上的值K（ - 100~100），
当行动力 <= 0时游戏失败，请问要从地图左上角移动到地图右下角至少需要多少起始行动力，
注意（玩家初始化到起始的左上角格子时也需要消耗行动力）

输入描述 :
第一行输入格子行列数（格式为 M N），第2~M + 1行每行输入N个数，作为格子值K，中间以空格分割；0 < M, N < 1000， - 100 < K < 100


输出描述 :
	 初始最小行动力
	 示例1
	 输入
	 2 3
	 - 2 - 3 3
	 - 5 - 10 1
	 输出
	 6


角色在(i, j)之前（即在(i - 1, j)或者(i, j - 1)，下一步即将移动到(i, j)）行动力用dp[i][j]表示，比如初始行动力为dp[0][0]，下一步即将移动到(0, 0)；

角色在(i, j)时（下一步即将移动到(i + 1, j)或者(i, j + 1)）行动力等于dp[i][j] + a[i][j]，比如初始行动力为dp[0][0]，角色在(0, 0)时行动力为dp[0][0] + a[0][0]；

角色在(i, j)之后（即在(i + 1, j)或者(i, j + 1)，上一步在(i, j)），此时有min(dp[i + 1][j], dp[i][j + 1])等于dp[i][j] + a[i][j]。


【分析】dp[i][j]表示角色尚在格子(i, j)之前并且即将要移动到格子(i, j)时的行动力。

dp[0][0]表示初始的行动力。

当行动力小于或者等于0时游戏失败，dp[i][j]必然大于或者等于(对应递推公式的max)1，即dp[i][j] >= 1。

dp[i][j] + a[i][j]表示角色在格子(i, j)但尚未往下移动时的行动力，此时行动力为min(dp[i + 1][j], dp[i][j + 1])，采用min是因为最后要求的是最小值。

最后求解初始时刻的行动力，则应该从后往前推理，可得，

dp[i][j] = max(1, min(dp[i + 1][j], dp[i][j + 1]) C a[i][j])。

#include<iostream>
#include<vector>
#include<algorithm>
using namespace std;
int main()
{
	int m, n;
	cin >> m >> n;
	vector<vector<int> > a(m, vector<int>(n, 0));
	vector<vector<int> > dp(m + 1, vector<int>(n + 1, 0));
	for (int i = 0; i<m; ++i)
	for (int j = 0; j<n; ++j)
		cin >> a[i][j];
	for (int i = m - 1; i >= 0; --i)
	for (int j = n - 1; j >= 0; --j)
		dp[i][j] = max(1, min(dp[i + 1][j], dp[i][j + 1]) - a[i][j]);
	cout << dp[0][0] << endl;
	return 0;
}